package de.abbaddie.rirc

import collection.immutable.{Map, HashMap, Set, HashSet}
import java.util.{Date, TimerTask, Timer}
import java.nio.file.{Path, Paths, Files}
import java.nio.charset.Charset
import java.io.{FileWriter, BufferedWriter}

object Munin extends BackupFileProvider {
	// vars + init
	private var interval : Int = 0
	private var pluginPath : Path = null
	private var plugins : Map[String, Plugin] = HashMap()
	private var graphs : Set[Graph] = HashSet()

	def filename = "jmunin"

	private def init() {
		setInterval(10)
		setPath("jmunin")
		val timer = new Timer
		timer.scheduleAtFixedRate(Writer, interval, interval)
	}

	// static plugin api
	def add(name : String, value : Int) {
		plugins get name match {
			case Some(plugin : StaticPlugin) =>
				plugin.synchronized {
					plugin.value += value
				}
			case _ =>
		}
	}

	def inc(name : String) {
		add(name, 1)
	}


	def dec(name : String) {
		add(name, -1)
	}

	def set(name : String, value : Double) {
		plugins get name match {
			case Some(plugin : StaticPlugin) =>
				plugin.synchronized {
					plugin.value = value
				}
			case _ =>
		}
	}

	def reset(name : String) {
		set(name, 0d)
	}

	// plugin creation
	implicit def igraph = { // (has to be public)
		val graph = new Graph(Nil)
		graphs += graph
		graph
	}

	def apply(graph : Graph, plugin : Plugin, gsettings : Seq[(String, Any)], lsettings : Seq[(String, Any)]) : Graph  = {
		graph.plugins += plugin
		plugins += (plugin.name -> plugin)
		graph
	}

	def apply(name : String, gsettings : (String, Any)*)(implicit graph : Graph) : Graph  = {
		apply(name)(gsettings :_*)(Nil :_*)(graph)
	}

	def apply(name : String)(gsettings : (String, Any)*)(lsettings : (String, Any)*)(implicit graph : Graph) : Graph  = {
		val plugin = new StaticPlugin(name, gsettings, lsettings)
		apply(graph, plugin, gsettings, lsettings)
	}

	def apply(name : String, getter : => Double, gsettings : (String, Any)*)(implicit graph : Graph) : Graph  = {
		apply(name, getter)(gsettings :_*)(Nil :_*)(graph)
	}

	def apply(name : String, getter : => Double)(gsettings : (String, Any)*)(lsettings : (String, Any)*)(implicit graph : Graph) : Graph = {
		val plugin = new DynamicPlugin(name, getter, gsettings, lsettings)
		apply(graph, plugin, gsettings, lsettings)
	}

	// configuration
	def setInterval(interval : Int) {
		this.interval = interval
	}

	def setPath(name : String) {
		this.pluginPath = Paths.get(name)

		val file = pluginPath.toFile
		if(!file.exists()) file.createNewFile()
		pluginPath.toFile.setExecutable(true)
	}

	init()

	class Graph private[Munin](val gsettings : Seq[(String, Any)]) {
		private[Munin] var plugins : Set[Plugin] = HashSet()
		var gsettingsMap = HashMap(gsettings :_*)

		private var namevar : Option[String] = None

		def name_=(name : String) {
			namevar = Some(name)
		}
		def name = namevar match {
			case Some(name) => name
			case None => plugins.head.name
		}

		def isSimple = plugins.size == 1
	}

	private object Writer extends TimerTask {
		def run() {
			var writer : BufferedWriter = null
			try {
				writer = new BufferedWriter(new FileWriter(getFile(write = true)))
				writer write "#!/bin/bash\n\n"
				writer write "# File generated by rirc at " + new Date().toString + "\n"
				writer write "# DO NOT EDIT\n\n"

				// config
				writer write "if [ \"$1\" = \"config\" ]\n"
				writer write "then\n"
				for(graph <- Munin.graphs) {
					writer write "\n"
					writer write "\n"
					writer write "\tprintf '\\n'\n"
					writer write "\tprintf '\\n'\n"
					writer write "\tprintf 'multigraph " + graph.name + "\\n'\n"
					if(graph.isSimple) {
						val plugin = graph.plugins.head
						for((key, value) <- plugin.gsettingsMap) {
							writer write "\tprintf 'graph_" + key + " " + value.toString + "\\n'\n"
						}
						for((key, value) <- plugin.lsettingsMap) {
							writer write "\tprintf '" + plugin.name + "." + key + " " + value.toString + "\\n'\n"
						}
					}
					else {
						if(!(graph.gsettingsMap contains "title")) writer write "\tprintf 'graph_title " + graph.name + "\\n'\n"
						if(!(graph.gsettingsMap contains "vlabel")) writer write "\tprintf 'graph_vlabel " + graph.name + "\\n'\n"
						for((key, value) <- graph.gsettingsMap) {
							writer write "\tprintf 'graph_" + key + " " + value.toString + "\\n'\n"
						}

						for(plugin <- graph.plugins) {
							writer write "\n"
							writer write "\tprintf '\\n'\n"
							writer write "\tprintf 'multigraph " + graph.name + "." + plugin.name + "\\n'\n"
							for((key, value) <- plugin.gsettingsMap) {
								writer write "\tprintf 'graph_" + key + " " + value.toString + "\\n'\n"
							}
							for((key, value) <- plugin.lsettingsMap) {
								writer write "\tprintf '" + plugin.name + "." + key + " " + value.toString + "\\n'\n"
							}
						}
					}
				}
				writer.write("\texit 0\n")
				writer.write("fi\n")

				// values
				for(graph <- Munin.graphs) {
					writer write "\n"
					writer write "\n"
					writer write "printf '\\n'\n"
					writer write "printf '\\n'\n"
					writer write "printf 'multigraph " + graph.name + "\\n'\n"

					if(graph.isSimple) {
						val plugin = graph.plugins.head
						val value = if (plugin.value.isValidInt) plugin.value.toInt.toString else plugin.value.toString
						writer write "printf '" + plugin.name + ".value " + value + "\\n'\n"
					}
					else {
						for(plugin <- graph.plugins) {
							writer write "\n"
							writer write "printf '\\n'\n"
							writer write "printf 'multigraph " + graph.name + "." + plugin.name + "\\n'\n"

							val value = if (plugin.value.isValidInt) plugin.value.toInt.toString else plugin.value.toString
							writer write "printf '" + plugin.name + ".value " + value + "\\n'\n"
						}
					}
				}
			}
			catch {
				case e : Exception =>
			}
			finally {
				if(writer != null) writer.close()
			}
		}
	}

	private sealed abstract class Plugin(val name : String, val gsettings : Seq[(String, Any)], val lsettings : Seq[(String, Any)]) {
		var gsettingsMap = HashMap(gsettings :_*)
		var lsettingsMap = HashMap(lsettings :_*)

		def value : Double

		if(!(gsettingsMap contains "title")) gsettingsMap += ("title" -> name)
		if(!(gsettingsMap contains "vlabel")) gsettingsMap += ("vlabel" -> name)
		if(!(lsettingsMap contains "label")) lsettingsMap += ("label" -> name)
	}

	private class StaticPlugin(name : String, gsettings : Seq[(String, Any)], lsettings : Seq[(String, Any)])
			extends Plugin(name, gsettings, lsettings) {

		var value = 0d
	}

	private class DynamicPlugin(name : String, getter : => Double, gsettings : Seq[(String, Any)], lsettings : Seq[(String, Any)])
			extends Plugin(name, gsettings, lsettings) {

		override def value = getter
	}
}